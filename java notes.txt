
	JAVA NOTES:
	==========
public class 2 {
		 
	public static void main(String args[])
		 {
			int age = 22; 
			int Age = 32;
			System.out.println(age);
			System.out.println("Hello World! Avinash B");
		 }
	
	}

public class PrimitiveDataTypes{
	public static void main(String args[]){
		
		// Variable Creation
		// syntax: datatype variableName = value;
		//integer dataType
		byte smallNumber = 70;
		short shortNumber = 15000;
		int integerNumber = 3765;
		long largeNumber = 9949405866L;
		
		//decimal DataType
		float decimalNumber = 3.14f;
		double largeDecimal = 3.14159d;
		
		//char
		char character ='A';
		
		//boolean
		boolean isJavaFun = true;
		
		System.out.println(smallNumber);
		System.out.println(shortNumber);
		System.out.println(integerNumber);
		System.out.println(largeNumber);
		
		System.out.println(decimalNumber);
		System.out.println(largeDecimal);

		System.out.println(character);
		System.out.println(isJavaFun);
			
	}

}
Literals
========

int age = 10;
10 is value or literal

Integral Literal types

1. Decimal Types:
	- base 10 Number
	 int age = 10;
	 System.out.println(age); //10
	 
2. Octal Numbers:
	- are base 8 numbers
	
	- Allowed digits in octal numbers are 0 to 7
	- Octals are represented as base 8 numbers
	- Octal literals Prefixed with 0 digit.
		exp : 010;
	
	int x =010;
	System.out.println(x);
	
3. Hexadecimal Numbers:
	- are base 16 numbers
	
	- Allowed digits in Hexadecimal numbers are 0 to 9 A,B,C,D,E,F
	10-A
	11-B
	12-C
	13-D
	14-E
	15-F
	- hexadecimal numbers are prefixed with 0x
	ex: 0x10;
	
invalid numbers are 0xg2, 0x12h

4. Binary Numbers:
	- are base 2 numbers
	
	- Allowed digits are 0 and 1
	- binary numbers must be prefixed with 0b or 0B
	
	
class LiteralsDemo{
	
	public static void main(String args[]){
	
		int octalNumber = 010; //  010 = 1*8^1+0*8^0
		System.out.println("Octal Number is: "+octalNumber);
		//int x = 0898;
		//System.out.println(x); throws error because 0898 is out of range for 0-7
		
		int hexaNum = 0x1A;
		System.out.println("Hexa Decimal Number is: "+hexaNum);
		
		//1*16^1 + 10*16^0
		
		int binNum = 0b1010;
		System.out.println("Binary Number is: "+binNum);
	
		int number = 10;
		long longNumber = number; // Casting of int to long ==> Type casting
	}
}
	
Conversion of one type to another type is called type casting

1.Implicit Widening (automatically)==> when trying to convert smaller to Bigger data type
				byte b =10;
			 int intVar = b;//implicit casting or Widening
			 No need of any special notation
2.Explicit narrowing (manually)==> when trying to convert bigger to smaller data type
			long longVar=3000;
			int intVariable = longVar; //Explicit or Narrowing
			need special notation
			
		Eg: int count = 10;
			short shortCount = (short)count;
			
	int to byte explicit casting
	
	int i = 130;
	byte b = (int)i;
	
1. 130 is converted in to binary numbers
		
		130 - 0000 0000 0000 0000 0000 0000 1000 0010 for int
		for byte only 8 bits
		so last 8 bits 
		1000 0010
		
		Inverting of 0 to 1's and 1 to 0'short
		
		1000 0010 ==> 0111 1101
		
		add 1,
		
		01111101
			  +1
		---------
	    01111110 ==> binary ==> -126
		
		
	class TypeCasting{

			public static void main(String args[]){
	
		//implicit casting from char to int
		char ch = 'A'; // 2bytes
		int num = ch;
		System.out.println(num);
		
		byte b = 10;
		short s = b;
		System.out.println(s); // byte==>short
		
		int i = s; //short ==> int
		System.out.println(i);
		
		long l = i; // int ==> long
		float f = l; // long ==> float
		System.out.println(l);
		System.out.println(f);
		
		// explicit casting
		double d1 = 123.4556;
		int i1 = (int)d1; //double ==> int
		System.out.println(i1); //123
		
		int largeNum = 130;
		byte by = (byte)largeNum;
		System.out.println(by);
		
	}
}

Operator:
---------
			An Operator is a symbol that represents an action to be performed on one or more operands.
		
		Eg: a + b;
		a, b are operands
		+ is a operator.
	Different types of operators are supported by java
	1. Arthmetic operators
	2. relational operators
	3. Bitwise Operators
	4. Logical Operators
	5. Assigment Operators
	6. Unary Operators
	7. Ternary Operator
	8. Shift Operator
	
1. Arthmetic Operators

	public class ArithmeticOperations {
    public static void main(String args[]) {
        
        int num1 = 100;
		int num2 = 12;

        
        int sum = num1 + num2;         // Addition
        int difference = num1 - num2;  // Subtraction
        int product = num1 * num2;     // Multiplication
        int quotient = num1 / num2;    // Division
        int remainder = num1 % num2;   // Modulus

        
        System.out.println("Number 1: " + num1); // 100
        System.out.println("Number 2: " + num2); //12
        System.out.println("Addition: " + sum); //112
        System.out.println("Subtraction: " + difference); //88 
        System.out.println("Multiplication: " + product); //1200
        System.out.println("Division: " + quotient); //8
        System.out.println("Modulus: " + remainder); // 4
    }
}
Increment and Decrement Operators:
==================================
++ Operator => it increments the operand by 1
int x = 10;
	++x; -> Pre increment Operator	==> In pre increment the variable is first incremented and then the updated value is used in
								expression
	x++; -> Post increment Operator ==> In post increment the value of the variable is first used in the expression and later it is
			incremented
	
-- Operator => it decrements the operand by 1
int y = 10;
	--y; -> Pre decrement Operator ==> In pre decrement the variable is first decremented and then the updated value is used in
								expression
	y--; -> Post decrement Operator ==> In post decrement the value of the variable is first used in the expression and later it is
			decremented

 class IncrementDecrement{
	public static void main(String[] args){
		
		//Increment
			//int i = 5;
			//int x = ++i;
			//int x = i++;
			//System.out.println(x);
			//System.out.println(i);
			
		//Decrement
			int i = 5;
			// int x =i--;
			int x = --i;
			System.out.println(x);
			System.out.println(i);	
	}
 }
Assigment Opeartors
===================
	Are used to assign some values to the variables
	they are used to assign the values on the right hand side to the variable on the left hand side
	syntax:
	variable = value;
	int b = 10;
	int a = b;
	Types of Assigment Opeartors:
	-----------------------------
	+= -> a+=b -> a=a+b
	-= -> a-=b -> a=a-b
	*= -> a*=b -> a=a*b
	/= -> a/=b -> a=a/b
	%= -> a%=b -> a=a%b
	
class AssignmentOperators {
	public static void main(String[] args) {
	
	// = assigment Operators
	int a = 10;
	int b = 5;
	//System.out.println("a+=b: "+(a+=b));
	//System.out.println("a-=b: "+(a-=b));
	//System.out.println("a*=b: "+(a*=b));
	//System.out.println("a/=b: "+(a/=b));
	System.out.println("a%=b: "+(a%=b));	
	}
}

Relational Opeartors:
=====================
Relational Opeartors are used to compare the value or expression
 their result is boolean either true or false
==,!=,>,<,>=,<=

class RelationalOp{
	public static void main(String[] args){
		int a,b;
		a = 10;
		b = 20;
		System.out.println(a>b);
		System.out.println(a<b);
		System.out.println(a==b);
		System.out.println(a!=b);
		System.out.println(a>=b);
		System.out.println(a<=b);	
	}
}

Boolean Operators:
==================
	- used with boolean values	
	- Always return true or false
	Different Boolean operators
	a. Boolean AND - &
		- returns true only if both operands are true
	b. Boolean OR - |
		- returns true if any one of the operand is true
	c. Boolean XOR - ^
		- returns true only if operands are different
			eg: true ^ false = true
		- returns false if both operands are same
			eg: true ^ true = false
				false ^ false = false
	d. Boolean Not - !
		- Boolean not reverses the boolean value
			eg: !true = false
				!false = true

class BooleanOperators{
	public static void main(String[] args){
		boolean a = true;
		boolean b = false;
		
		// Boolean Operations
		System.out.println("Boolean AND: "+ (a&b));//false
		System.out.println("Boolean OR: "+ (a|b));//true
		System.out.println("Boolean XOR: "+ (a^b));//true
		System.out.println("Boolean NOT: "+ (!a));//false
	}
}
Logical Operators:(Short Circuit Operators)
==================
	- are used to perform logical operations a=on boolean operands
	- Logical AND Operator - &&
		- returns true only if both operands/expressions are true
			eg: expression1 && expression2 
	- Logical OR Operator - ||
		- returns true if any one of the operand/expression is true
	- Logical NOT - !
		- reverses the expression's/operand's boolean value

class LogicalOperators{
	public static void main(String[] args){
		int x = 5;
		int y = 10;
			//Logical AND
		boolean result = (x>0 && y>5);
		System.out.println("Logical AND: "+result );// true
			//Logical OR
		boolean result1 = (x>10 || y>5);
		System.out.println("Logical OR: "+result1 );// true
			//Logical NOT
		boolean result2 = !(x>y);
		System.out.println("Logical NOT: "+result2 );// true
	}
}
Logical ==> short circuited 
x=0; y=0;
boolean result2 = (++x<0 && ++y>0);
	System.out.println(result2);//false
	System.out.println("X: "+x);//1
	System.out.println("Y: "+y);//0
	
	here 1st expression is false so the 2nd expression cannot be evaluated so 
	there is a break so y cannot be incremented
	
	
boolean 
System.out.println("Boolean Operators &");
	x=0; y=0;
	boolean result4 = (++x<0 & ++y>0);
	System.out.println(result4);false
	System.out.println("X: "+x);//1
	System.out.println("Y: "+y);//1
	
	here the boolean operator checks both the expressions if the solution comes in 1st 
	expression
	
CONTROL FLOW STATEMENTS:
------------------------
Control flow refers to the order in which the statements and block of code are executed during the runtime
of the program

	- Control flow determines the flow of execution based on certain conditions
	- Control flow allow the program to make decisions and repeat the actions based on those 
	conditions

	Control flow statements can be categorized into 2 typesL
	1. Decision Making statements
	2. Looping Statements
	
Decision Making statements:
	i. if statement: syntax:if(conditions or Boolean exp)
								// statement1;
							else
								// statement2;
	ii. if else ladder: syntax: if(condition1 or Boolean_exp1)
									{
								statement1	
									}
								else if(condition2 or Boolean_exp2)
										{
										statement2
										}
									else if(condition3 or Boolean_exp3)
											{
											statement3
											}
										else if(condition4 or Boolean_exp4)
												{
												statement4
												}
								else
								{
								statement5;
								}
		
import java.util.Scanner;
class CustomerDiscountSystem{

	public static void main(String[] args){
	
		int bronzePoints = 1000;
		int silverPoints = 5000;
		int goldPoints = 10000;
		
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter you Loyalty Points: ");
		int points = sc.nextInt();
		// Determine the discounts based on the points
		if(points>=goldPoints){
			System.out.println("You are a Gold Member");
			System.out.println("You will get a 50% discount on all purchases");
		}else if(points>=silverPoints){
			System.out.println("You are a Silver Member");
			System.out.println("You will get a 20% discount on all purchases");
		}else if(points>=bronzePoints){
			System.out.println("You are a Bronze Member");
			System.out.println("You will get a 10% discount on all purchases");
		}
		else{
			System.out.println("No discount available earn more loyalty points");
		}
		sc.close();
	}
}
ternary Operator:
------------------

Syntax: variable = (condition)? value1 : value2

Switch Statement:
------------------
	Switch statement is used for branching logic based on the value of a variable.
	
		Its Alternate for if else Statements when we check a single variable 
		against different possible values(cases).
		
		It works with byte short int, char, String, or enum type
		
		Support break Statement to exit the switch block after a case matches
	
Looping Statements:
-------------------
	Looping statements are used to repeatedly execute the block of code
	Types:-
	
	1. for loop
	2. while loop
	3. do while loop
	
1. for: for looping statements
--------
	for(intialization;condition;updation){
	/*	
		statements
	*/
	}
2. while: 
----------
	while(condition){
	/*
		Statements
	*/
	}
	- Also called as a top tested loop
	  Every time the testing of boolean expression will be done at the top of the loop
	- suppose if the boolean expression is false at the very first time, program control
	  will not execute the body of the loop atleast once.
	 - so the minimum number of executions of the while loop body is zero.
	 
3. do while:
------------
	do{
	/*
		Statements;
	*/
	}while(condition);
	- Also called as a bottom tested loop
	- the condition will be executed after the body of the loop is executed.
	- if the condition is true, the program control goes to the next iteration
      otherwise it comes out of the loop
	- As the first time body of the loop executes without having to rest the condition. 
	  So minimum number of execution is one.
	  
Jumping statements:
-------------------
	Jumping statements in java are used to transfer control from one part of the program 
	to another.
	- these statements are mainly used to change the normal flow of execution based on certain condition.
	
	- The following are the jumping statements used in java
	1. break:-
			- Syntax: break;
			-  when a break statement is used inside a loop, program control jumps 
				out from the loop without executing the remaining Iterations in the 
				current loop.
	2. continue:-
			- Syntax: continue;
			- when a continue is used inside a loop program control skips the current iteration,
				and continues with the remaining iterations in the current loop.
	3. return
	
	
Arrays:
--------
package arrays;

public class ArrayDemo1 {

	public static void main(String[] args) {
		
//		int a = 10;
//		int b = 20;
		
		//int intArray[] = {10,20};// inline creation of array, generally not used
		
		int intArray[] = new int[3];// used frequently
		int arrayLength = intArray.length;
		System.out.println("length of array is: "+arrayLength);
		intArray[0]=10;
		intArray[1]=20;
		intArray[2]=30;
		System.out.println(intArray);// address of intArray is printed
		for(int i =0;i<arrayLength;i++) {
			System.out.println(intArray[i]);
		}
		//System.out.println(intArray[0]+intArray[1]);
		

	}

}


Jagged Array:
-------------
it is a multi-dimensional array where the inner arrays can have different lengths

	- It is also called as ragged array, because the structure is irregular.
	- Jagged arrays is an array of arrays with different sizes
	
	
	package firstjavaproject;

public class JaggedArray {
	public static void main(String[] args) {
		// declaration of jagged array
		
		int[][] jaggedArr = new int[3][];
		
		//define different column sizes for each row
		
		jaggedArr[0] = new int[] {1,2,3};// row 1-> 3 columns
		jaggedArr[1] = new int[] {9}; // row 2 -> 1 columns
		jaggedArr[2] = new int[] {5,6,7,8};// row 3 -> 4 columns
		
		for(int i = 0;i<jaggedArr.length;i++) {
			for(int j =0;j<jaggedArr[i].length;j++) {
				System.out.print(" "+jaggedArr[i][j]);
			}
			System.out.println("");
		}
	}

}



Strings:
----------
	- String in java is sequence/group/array of characters
	- String can be created in differe ways
	
	1. Using Literal 
	 Eg: String myString = "Hello";
		
		String created usinh a literal (directly assigning the const value to s string variable 
										without new keyword)
		Literals stored in a special memory region inside the heap memory called
		"String constant pool" or "String pool" SCP/SP or pool
	
	2. String can also be created using a 'new' keyword.
	 Eg: String company = new String("Codegnan");
	 
	 
	 String-->Predefined Class
	 company--> Reference variable stored in stack memory
	 new --> new keyword which used to allocate memory For object in heap, each object have unique address
	 String()-->String class Constructor which is used to construct objects of String
	 
	 Strings created using a new keyword are stored in a memory area called heap memory
	 the variable which is referencing this String object is stored in Stack memory
	 
	 When a same String object is created again with new keyword, a new String object gets created in heap
	 memory
		String myGreeting = new String("Good");
		String myGreeting1 = new String("Good");
			in the above scenario  2 separate string objects are created in heap
	In case of String Literals 
	when a same literal is created again, anew string object will not be Created 
		String greeting1 = "Hi";
		String greeting2 = "Hi";
			In the above w Hi objects will not be created only a single Hi objects exists
			in SCP/SP
			In SCP/SP a new object by JVM only if it is already not present in the pool
	
	This is the reason why the performance of string literals are good when compared to strings created
	with new keyword
	the memory is optimized when string literals are used (less amount of memory is consumed)
			
	 
	 +----------+---------------+
	 |	Stack	|	Heap		|
	 |----------+---------------|
	 |	company-|-->Codegnan----|--> String with new keyword
	 |			|	 _____		|
	 |			|	|	  |		|
	 | myString-|-->|Hello|-----|--> String with literal stored in SCP/SP in the Heap memory
	 |			|	|_____|		|
	 +----------+---------------+
	 
Opeartor "==" and equals() method
== Operator:
------------
== operator checks the reference equality, It retur a boolean true or false 
	- if both the objects are refering to the same address then == returns true
	- if both the objects are refering to the different address then == returns false
equals method:
--------
equals() method compares the content of the string object.
equals method returns true if both the objects have same content or else false

String Immutable:
-----------------
	The word 'Immutable' means unchangable or unmodifiable or unaltered 
	the opposite for immutable is mutable.
	Mutable means something which changes or something which can be changed
	
	String Objects in java are by default 'immutable', meaning they cannot be changed once created
	
	Even when concat() method is applied on string, the string remains unchanged.
	A new String object will be created in heap memory

Methods of String:
-----------------
	1. concat(): concat() is used for combining strings
	2. intern(): When the intern() method is invoked, if the pool already contains astring equal to
		this String object as determined by the equals(Object) method, then the string from the pool is returned. 
		Otherwise, this String object is added to thepool and a reference to this String object is returned.
	3. indexOf(char ch): returns the index of the first occurance of the specified character
	3. substring(beginIndex,endIndex): used to extract the part of the string using beginingIndex and endIndex
	Returns a string that is a substring of this string. Thesubstring begins at the specified beginIndex andextends to the character at index endIndex - 1.Thus the length of the substring is endIndex-beginIndex. 
Examples: 

 "hamburger".substring(4, 8) returns "urge"
 "smiles".substring(1, 5) returns "mile"
 
Parameters:beginIndex the beginning index, inclusive.endIndex the ending index, exclusive.
Returns:the specified substring.Throws:IndexOutOfBoundsException - if the beginIndex is negative, or endIndex 
is larger than the length ofthis String object, or beginIndex is larger than endIndex.
	4. charAt(int index) method: used to extract character at the specified index
	5. trim() Trimming the string- removing the trailing and leading spaces=
	6. split() splits the string using delimiter and returns array
package firstjavaproject.strings;

public class StringIntern {

	public static void main(String[] args) {
		String s1 = "abc";
		String s2  = "abc";
		System.out.println(s1==s2);//true
		
		String s3 = new String("abc");
		System.out.println(s1==s3);//false
		
		//appling the intern() method
		s3=s3.intern();
		System.out.println(s1==s3);
		

	}

}
package firstjavaproject.strings;

public class StringMethodDemo {
	public static void main(String[] args) {
		String email = "avinash@gmail.com";
		//indexOf() method: returns the index of the first occurance of the specified character
		System.out.println(email.indexOf('s'));
		
		//substring() method: used to extract the part of the string
		System.out.println(email.substring(0, 7));//
		System.out.println(email.substring(4, 5));
		
		String userName = email.substring(0,email.indexOf('@'));
		System.out.println("USERNAME: "+userName);
		
		//charAt() method: used to extract character at the specified index
		System.out.println(email.charAt(3));
	}
}

	
package firstjavaproject.strings;

public class StringReverse {

	public static void main(String[] args) {
		String input = "java";
		
		//toCharArray()
		char[] inputArray = input.toCharArray();
		for(char i: inputArray) {
			System.out.print(i+"\t");
		}
		System.out.println("\n===========Reverse String============");
		//to reverse the string
		for(int i=inputArray.length-1;i>=0;i--) {
			System.out.print(inputArray[i]+"\t");
		}
		System.out.println("\n=====Upper and Lower======");
		System.out.println(input.toUpperCase());
		System.out.println(input.toLowerCase());
		System.out.println("=Trimming the string- removing the trailing and leading spaces=");
		String s = "     Hyderabad     ";
		System.out.println(s.trim());
		System.out.println("\n=====startsWith======");
		String greeting = "Hello World";
		// startsWith() it returns boolean value true if the string starts with the specified string
		// in the startswith() method 
		
		System.out.println(greeting.startsWith("Hello"));
		//length() method 
		System.out.println(greeting.length());
		//Split() method
		String fruits = "Apple,Bannana,Cherry";
		String[] strArray =fruits.split(",");// delimiter is comma (,)
		for(String str: strArray) {
			System.out.print(str+" ");
		}
		System.out.println();
		String myStr="boo:and:foo";
		String[] bArray=myStr.split(":");//delimiter is colon(:)
		for(String str:bArray) {
			System.out.print(str+" ");
		}
	}

}
	StringBuilder and StringBuffer:	Both are 2 classes, which supports mutablity of strings
	-------------------------------
	- we can create mutable(Strings can be modified) strings using StringBuilder and StringBuffer.
	- the difference between StringBuilder and StringBuffer is that, StringBuilder is not suitable in
		multi-threaded environment.
		StringBuffer is suitable for multi-threaded programs
		
	- StringBuffer internally implements the concepts of thread syncronization which prevents multiple threads 
		to access the synchronized data at the same time.
		
	- Since StringBuilder doesn't implement syncronization, it is not thread-safe 
	- StringBuffer implements syncronization, so it is a thread-safe i.e., it is safe to use in multi-threaded environment.
	
	append(): add text at the end.
	StringBuffer strBuff = new StringBuffer("Core");
		strBuff.append("java");
		s.o.p(strBuff);// corejava
	insert(): insert texts at specified index
		strBuff.insert(5,"Language");
	replace(): replaces portion of the String
	strBuff.replace(5,9,"Great");
	delete(): removes a portion of the text
	strBuff.delete(3,7);
	reverse(): reverse the given string
	StringBuffer str = new StringBuffer("java");
	str.reverse(); //avaj
	
package firstjavaproject.strings;

public class MutableString {

	public static void main(String[] args) {
		String greeting = "Hello";
		greeting.concat("World !");// immutable
		System.out.println(greeting);
		
		StringBuilder myGreeting = new StringBuilder("Hello");
		myGreeting.append(" World!"); // mutable String
		System.out.println(myGreeting);
		
		StringBuffer myGreeting1 = new StringBuffer("Hi");
		myGreeting1.append(" How are You");
		System.out.println(myGreeting1);

	}

}
Methods in JAVA
---------------
	- Method in java is a block of code is used to perform a specific task
	- Methods help to reuse the code,(helps to avoid redundancy) and to organize the code in a better way
	- A method must be inside a class.
	- It will be executed only when it is called(invoked).
	- A method may or may not take input parameters
	- A method may return or may not return a value.
	
	Instance methods:
	------------------
		- A object reference variable is required to call instance methods
		- it belongs to the object of the class
	Static methods:
	---------------
		- An object reference variable is not required to call methods
		- we use keyword static in method declaration while creating a method
		- it belongs to the class itself not the object
	
	Syntax to create a method:
	--------------------------
		access_modifier return_type methodName(){
		
		//code block
		
		}
	where access_modifier can be public, private, protected or without any modifier(default)
	return_type: A method can return a value, it can be of any type.(for eg, int String, char,..)
				when a method doesnt return a value we use keyword called void
				void means nothing
	methodName: is the meaningful name of the method, its a convention to start a method
				name with lower case letter
			(): A method is followed by parenthesis or bracket, inside this () we provide 
				arguments (inputs to the method) if required
		
	** For static methods we use static keyword before the return_type
	
	Method with return_type:
		- A method with return_type(i.e.,a method without return_type) must have a return statement as last statement
		syntax:
	access_modifier return_type methodName(){	
	//code block
	return value;
	}
	
package firstjavaproject.methods;

public class MethodsDemo2 {
	//a method without return type and no arguments
	public void welcomeMessage() {
		System.out.println("Welcome Avinash !");	 
	}	
	//a method without return type and no arguments
	public static void helloWorld() {
		System.out.println("Hello World");
	}
	//a method with int return type and no arguments
	public int diplayNumber() {
		return 25;
	}
	//a method with string return type and no arguments
	public String diplayString() {
		return "Avinash";
	}
	//a method without return type and with arguments
	public static void main(String[] args) {
		MethodsDemo2 message = new MethodsDemo2();
		message.welcomeMessage();// Invoking or calling the instance method
		helloWorld();// static method calling
		int value = message.diplayNumber();
		System.out.println(value);
		System.out.println(message.diplayString());
	}
}

Recursion:
----------
	example: 
		public void doSomething(){
			doSomething();
		
		}
	
	recursive method is a method which calls itself
	base case: 
		- base case in recursion is the case which stops the recursion process, can also 
	call it stopping condition without a base case the recursion process will not stop and continues infinitely
	then an exception called "StackOverFlow" exception occurs, and the program terminates abnormally/crashes
	
	recursive case: 
		- The method calls itself with a modified argument eg: (n-1)
		- eg: factorial(n)=n*factorial(n-1)
	stack behavior in recursion:
		- stack is a memory region(data structure) which follows the LAST IN FIRST OUT principle.
		- each time when a method is called, this method is pushed into a stack by creating a stack frame
			for that method.
		- for the next method call, a new stack frame is created on top of the previous stackframe.
        - each of these stackframes are executed in order of top to bottom i.e., the stackframe at the top is 
            executed and removed once completed. this process continues till the method in the 1st stack frame
            is executed.
        - after all method calls are completed, stack gets empty and it is deleted
		- when a method is called infinitely number of times then an exception called "StackOverFlow" exception occurs, 
				and the program terminates abnormally/crashes
	
======================================================================================================================
OOPS 
=====
Class: blue print for an object
	Template for an object
	specification to an object
	it is a logical entity 
Object: Instance of a class
		objects follows the specification given by the class
		It is a physical entity
		
Syntax to create a class:

	class <ClassName> {
	
	//variables
	//methods
	
	}

Syntax to create an Object:


	ClassName objRef = new ClassName(); //ClassName() is class Constructor
	eg: Car car = new Car();
	
	In the above ,
	
	- ClassName is the class
	- ObjRef is a variable which holds the reference(address) of the object
	- new Keyword is used to allocate memory for the newly created object in the heap memory
	- ClassName() is class constructor is used to initialize the class object
	package OOPS;

public class Car {
	//instance variables
	String engine;
	int mileage;
	String model;
	double price;
	String color;
	
	public static void main(String[] args) {
		Car kia = new Car();
		kia.engine="Diesel engine";
		kia.mileage=14;
		kia.model="Seltos";
		kia.price=1500000;
		kia.color="blue";
		
		System.out.println(kia.engine);
		System.out.println(kia.mileage);
		System.out.println(kia.model);
		System.out.println(kia.price);
		System.out.println(kia.color);
		
		Car honda = new Car();
		honda.engine="Petrol Engine";
		honda.mileage=12;
		honda.model="i";
		honda.price=1000000;
		honda.color="white";
		
		System.out.println(honda.engine);
		System.out.println(honda.mileage);
		System.out.println(honda.model);
		System.out.println(honda.price);
		System.out.println(honda.color);
	}
}
	
package OOPS;

public class Animal {
	String color;
	String size;
	String type;
	int walk;
	public static void main(String[] args) {
		Animal lion = new Animal();
		lion.color="Yellow";
		lion.size="Big";
		lion.type="Carnivorus";
		lion.walk=4;
		System.out.println("Lion color: "+lion.color);
		System.out.println("Lion size: "+lion.size);
		System.out.println("Lion type: "+lion.type);
		System.out.println("Lion walks on: "+lion.walk+" legs");
		
		Animal rabbit = new Animal();
		rabbit.color="Brown";
		rabbit.size="medium";
		rabbit.type="Herbivorous";
		rabbit.walk=4;
		System.out.println("Rabbit color: "+rabbit.color);
		System.out.println("Rabbit size: "+rabbit.size);
		System.out.println("Rabbit type: "+rabbit.type);
		System.out.println("Rabbit walks on: "+rabbit.walk+" legs");
		
		Animal human = new Animal();
		human.color="fair,black,brown";
		human.size="medium";
		human.type="Omnivore";
		human.walk=2;
		System.out.println("Humans color: "+human.color);
		System.out.println("Humans size: "+human.size);
		System.out.println("Humans type: "+human.type);
		System.out.println("Humans walks on: "+human.walk+" legs");
		
	}
}
	
	
Constructor:
	- constructor is used to initialize the class object
	- Constructor can be created either with arguments or without arguments.
	
	Constructor without arguments:
	- A constructor without any arguments is called no-argument constructor
	- It can also be a default constructor for a class
	- The default constructor is available for every class when it is created
	- Default constructor will initiate the object with default values as follows:
	
		For Primitives:
		
		dataType         default value
		---------         -------------
		int--------------------> 0
		double-----------------> 0.0
		float------------------> 0.0
		short					0
		long					0
		char
		boolean					false

		For Non primitives:
		String-----------------> null

constructor:	
parameterized constructor:
	Syntax:
		accessModifier constructor(param_type1 parameter1, param_type2 parameter2,....){
			//statements
		}

	in the above, 
	access modifier can be public private, protected or default (without any modifier)
	constructor is the name of the class
	Braces()- are used to specify the arguments for the constructor.
	
	A constructor will always have the same name as the className.
	A class will always have a default constructor, even though we are not
	explicitly creating it.
	A parameterized constructor must be created explicitly in the class.
	When an object is created, the code in the constructor will be executed first.
	
Constructor Overloading:
	- There can be any number constructor for a class but each constructor must have a different
	number of arguments
	- A constructor is said to be overloaded when you create one or more constructors in a class 
	otherthan the default constructor.
	
	Copy constructor:
	- It is a constructor which is used to create exactly the same copy of already existing
	object.
	- A copy constructor takes another similar type of object as paramters
	- It copies all its attributes/properties/fields to the new object.
	- this is used to remove ambiquity for jvm used to refer to the current object.
	
	Eg: Student(Student otherStudent){
		this.name=otherStudent.name;
		this.age=otherStudent.age;
		etc...
	}
	
	Using copy constructor:
	Student student= new Student("Ravi",23);
	//copying of student to studentCopy
	Student studentCopy = new Student(student);

this keyword:
	- this is a keyword in java which is used to refer the current object of a class.
	- it is used to differentiate btw instance variables and parameters	with the same name.
	- this keyword is also used for calling another constructor of the same class
	- calling another constructor of the same class from a constructor is called
		Constructor chaining
	- constructor chaining is achieved using a this keyword with parethesis.
	
	
	syntax: this() or this(parameters)
	this() call must be first statement
this()->call constructor without arguments
this(parameters)-> call constructor with arguments
call methods using this keyword this.methodName();

since this keyword refers to an object/instance, it cannot be used in static methods.

Polymorphism:
------------
	polymorphism means many forms.
	Eg: In a class there can be constructor with same name existing in different
		forms.
		In a class there can be a method with same name existing in different forms.
	
	Overloading is an example of polymorphism.
	A constructor is said to be overloaded if it exists multiple times with different arguments in a class
	A method is overloaded if it exists multiple time with different arguments
	
Encapsulation:
--------------
	- Encapsulation is the principle of hiding the data by making instance variables as private and allowing the 
	controlled access to thses variables using getter and setters.
	
	- Declaring the fields as private prevents the direct acces to the fields from outside the class.
	Eg: employee.name; which is not possible
	
	- getter methods: these methods are also called as "accessors" as they are used to access the data in the instance variables
	
	- setter methods: these methods are also called as mutators because the can be used to set/modify the data in the instance\variables.
		these methods allow us to modify values with validations/checks.
		
	Using encapsulation, internal implementation of the class can be changed without affecting external code
	Since data access is controlled, finding the errors(debugging) and testing of the code becomes easy.
	
	Initializer blocks in a class:
	
	Class loading Process:
		1. when we create a class and compile it, .class file will be generated
		2. JVM has to load this class using class loader on the memory
		3. the class is instantiated once we create the object using new keyword
		4. the created object will be instantiated by calling the constructor

	Static block:	is used to execute a block of code using the class loading process
	-------------	
					- static initializer block
					- belongs to a class, not to any specific object
					- static variables can be initialized using static block
					- we cannot access instance variables from static block
					- runs before main method and before any objects are created.
	 Syntax for static block:
	 static{
		//statements 
	 }
	 Instance block: it belongs to any object/instance of the class
	 ---------------
					- also called instance initializer block.
					- it executes everytime an object is created before the constructor.
					- used for common initialization tasks.
					- can access both static and instance members.
					- it runs each time when an object is instantiated.
	 syntax:
	 
	 {
		//statements
	 }
	 
	 public is an access modifier -  which allows a method to be access from anywhere
	 static is keyword when applied to a method, the method is accessible
		without object reference. it can be accessed directly with classname also
	void - when a method doesnt return anything then we use a keyword void to say that the methods doesnt return anything
	
	main() its the name of the method
	String[] - Array of Strings or string array
	args - arguments variable name of the String array
	
	we can pass arguments to the string array as follows
	
	java className arg1 arg2 arg3 ... argn
	
	System.out.println();
	
-System is a final 

Inheritance:
------------

- Inheritance is one of the core principle of oop's.
- Inheritance allows one class to inherit properties and behaviour from another class.
- Inheritance helps to reuse the code.
- Inheritance helps to establish the relationship between classes.
- we use keyword called extends.


-The class from which another class inherits the properties is generally called parent class or base class or super class.
- The class which inherits the properties form another class is known as child class or derived class or subclass.

	parent - child
	base - derived
	super - subclass
Syntax:

class parent{
}
class child extends parent{}
the keyword is used tro specify the relation between a child and parent.
"extends" means inheriting


this() vs  super():

this() is used to call the constructor of the same class
super() is used to call the constructor of the super class

Both this() and super() must be first statement in the constructor.
we cannot use this() and super() in the same constructor. If we use together it will result to compilation error.

Rules for method overloading and method overriding:
------------------------------------------------------
method overloading: - Two or more methods having same name but with different parameters.(different number of params,different types,different order).
                    - Overloading can have any return type, return does not matter in the method Overloading.
					- Methods must present in the same class.
					- static methods can also be repeated.
					- constructors can also be overloaded.
Method overloading is a example of static method dispatch or static polymorphism.
Methods are resolved during the compile time. So, it is also called as compile time polymorphism.


Method Overriding: - Same method name , same parameter list, same return type.
                   - Return type can also be covariant return type.
				   - when a method in a parent class is overridden in child class, the overidden method in child class
						can have the same return type as parent class method or it can have a covariant return type.
				   - covariant return type is a type which is subclass to the parent class methods return type.
				   - static methods cannot be overridden, if a same static method is implemented again in the child class it is not 
				     called method overriding, it is called as method hiding.
				   - private methods cannot be overridden.
				   - constructors cannot be overridden.
				   - 'final' method cannot be overridden.
				   - Method overriding is an example for dynamic  method dispatch. or dynamic polymorphism.
				     methods are resolved during the runtime. So, it is also called as runtime polymorphism.
					
					
	 - access modifiers: 
	--------------------
			public - public is an access modifier which allows access from anywhere.
				   - public can be accessed anywhere within the package or outside the package.
							package is group of related classes
						eg: inbuilt packages:
							java.io;
							java.util.*;
							java.lang.*;
			no modifier: a method or a variable or a class can be declared without any access modifier.
							- such modifiers are generally called default modifiers. 
							- such methods are also called as package-level modifier.
							- methods/class/variables declared without modifier can be accessed only inside the classes 
							present in the same package.
								
					
Final keyword:
--------------
- final keyword can be used with a class , with a method, and with a variable.
final keyword with respect to a class:
-  When a final keyword is used in the class declaration, the class cannot be inherit
   we cannot have child classes  for final classes.
   Eg: final class employee{}
   
final keyword with respect to Method:
 - we can use final keyword in a method declaration.
 - when a method is declared as final method, it cannot be overridden in the child classes.
 eg:public final void doSomething(){
	 statements
 }

final keyword with respect to variable:
 - we can use final keyword in a variable declaration
 - when a variable is declared as final, it cannot be reassigned.
 eg: public final double PI = 3.14;
 - final keyword for variable is generally used to specify the constant values.
 
 
 
 Relationship between classes:
 
 a. association : When one class is association with another class is called association.
 b. composition : Composition is a special type of association, also known as "HAS-A"
 for eg: if we 
 
class Car{
	HAS-A Relation
	Engine engine;
}

class Engien{

}
		Access Modifiers:
		================

							same Class			same package			Another package
							----------			------------			---------------
			public			available			available				available
			
			private			available			not available			not available
			
			no modifier 	available			available				not available
			
			protected		available			available				not available (available only when this class is 
																						subclass of class in another package)
			
	access restriction levels:
	-------------------------
	public < protected < no accessModifier < private
	
	parent class modifier				allowed access modifier for overridden method in subclass
	---------------------				---------------------------------------------------------
	private											not accessible at all, cannot be overidden
	
	no access modifier								no modifier, protected, public
	
	protected										protected, public
	
	public											only public
	
abstract method: it is a method with only declaration, it will not have implementation(body)
					terminated with a semicolon

concrete method: are methods which have declaration as well as implementation (body).
					implementation is provided inside the curly {} braces.
	
	package OOPS.inheritence;

public class AbstractDemo {
	//concrete
	public void method1() {
		System.out.println("abstract method");
	}
	// concrete // class allows only concrete methods
	public void method2() {
		
	}
	// we cannot abstract methods in a normal class interface only allows abstract methods
//	public void method3();
}

package OOPS.inheritence;

public interface AbstractDemo {
	//concrete
//	public void method1() {
//		System.out.println("abstract method");
//	}
//	// concrete // class allows only concrete methods
//	public void method2() {
		
	//}
	// we cannot abstract methods in a normal class interface only allows abstract methods
	public void method3();
}

Interfaces: 
	- interfaces will not have concrete methods.
	- interface can have abstract methods.
	- interface can also have variable declaration.
	- interface methods are terminated with semi colon(;)
	- class is a specification to an object.
	- interface is a specification to a class.
	- to used an interface in a class, we have to implement(provide) the body to all the methods of an interface.
	
	syntax to create an interface:
	
	interface <interface_Name> {
		
		// variable declaration
		// abstract methods declaration
		
	}
	
	- 'interface' is the keyword used to create an interface
	- interface_Name is the name of the interface
	
package OOPS.inheritence;

interface College {
	// default method allowed from java 8 onwards
	default void myMethod() {
		
	}
	//static method from java 8 onwards
	static void myMethod2() {
		
	}
}

Abstract classes:
=================
			- abstract classes in  java allows both abstract methods and concrete methods.
			- abstract classes cannot be instantiated.
			- abstract classes need to be extended by subclass.
			- abstract classes can have constructors.
			- abstract classes 

Abstraction:
------------
		- abstract and interfaces:
	
	when to use:
	Abstract classes can be used in the following situations:
		- theyare generally used when you have closely related subclasses(child classes).
		- you can use abstract classes when you want to declare non-static or non-final fields
		- you can use abstract classes when the child classes have many common methods or fields
		
	Interfaces can be used in the following situations:
		- they are generally used when you have unrelated subclasses(no common behavior)
		- You can use interface when you just want to specify the behavior(method) of a particular type, but not concerned about who
			implements its behavior.
		
	Diamond Problem:
	
		   Class X				valid
		   method1()
		
		/			\
	
	class A			class B		both are valid
	method1()		method1()
	
		\			/
	
			class C				invalid
			method1()
			
	Diamond Problem:
		- it generally occurs in multiple inheritence, where a class inherits from 2 classes which inherit from
			a common super class.
			- this creates ambiquity because compiler cannot determine which version of the inherited method to use.
			- in the above example class A and Class B are inheriting from a common class class X
			Class C is trying to inherit from class A and class B at the same time, so compiler cannot understand 
			which method1(class A's method1() or class B's method1()) to inherit.
			- this is called ambiquity.
			- java avoids this kind of situation by only allowing a single class to extended.
			- so we can say that java avoids multiple inheritence for classes.
			
			- In other words, we can say a class cannot extends more that a single class.
			example: class C extends A,B --> Invalid.
					 class C extends A --> valid.
					 class C extends B --> valid.

	mutli-level inheritence:
	-----------------------
			Class X				valid
		   method1()
		
		/			\
	
	class A			class B		both are valid
	method1()		method1()
	
		\			
	
			class C				valid
	
	Interfaces extension:
	--------------------
	
	Interface A											interface C{
		|	implements -->valid								method3();
	Class A												}
	  
	Class A implements A{
	}
	  
	interface A
	method1()
		|		extends --> valid
	interface B
	method2() + method1()
	
	interface B extends A{
		
	}
	
class A implements B,C{
	method1(){
	}
	method2(){
	}
	method3(){
	}
}

Variables:
----------
	Static variables: 
		- static variables belong to the class.
		- static variables will have a single copy in memory, which is shared by all the objects.	
		- static variables are declared using static keyword.
		- declared inside a class, but outside the method.
		- static variables can be accessed using classname(eg: classname.variableName)
											using object reference
		- static variables will have default values if they are not initialized explicitly.
		
	Instance variables:	
		- instance belong to instance of a class.
		- each object will have a separate copy of instance variables.
		- instance variables can be accessed directly in instance method.
		- instance variables cannot be accessed directly in static methods,
		- we can access instance variables with the help of object reference
			eg: myObjRef.age;
		
	Local variables:
		- which are created inside a method of a class
		- variables inside a constructor, variables inside a block of code.
		- local variables are created when the method/block executes and destroyed after it ends.
		
 Exceptions in java:
 
	- when a program abnormally terminates due to an exceptional/abnormal situation,
		we call that situation an exception.
		
	- An abnormal situation which disturbs the normal flow of execution of the program is known as exception.
	
	- Eg: Dividing an integer with zero.
		java doesn't allow dividing with a zero, it results in abnormal situation and the program will terminate.
	
This exceptional/abnormal situation can be handled in java prg using a mechanism called exception
handling.

	Exceptions can be broadly categorized into 2 types:
		1. runtime Exceptions:
		Eg: ArrayIndexOutOfBoundException, ArithmeticException
			- Also known as unchecked exceptions
			- runtime exceptions are the subclasses of runtimeexception class.
			- runtime exc cannot be seen during compile time
			- they are only visible when we execute
			- exception need not be handled during the compilation time
			- they are called unchecked as they are not checked by compiler.
			- It is always a good practice to handle unchecked exception also.
			
		2. Compile Time Exceptions:
		Eg:  IOException, SQLException etc.
			- Also known as checked exceptions
			- Checked exceptions are the classes which are not the subclasses of runTime Exceptions
			- Compile Time exceptions are visible during the compile time itself
			- the program will not compile unless we handle the exception.
			- they are called checked exceptions as they are checked by the compiler.

Handling an exception: An exception can be handled using a special block called 'try' block followed by 'catch' block
Syntax:
	try{
		
		//exception causing code or risky code
	}
	catch(Exceptionclass ref){
		//exception handling code
	}
	
Eg:       int val1=100; 
		  int val2 = 0; 
		  try { 
		  System.out.println("main method executing...");
			  int q=val1/val2;//abnormal situation exception causing statement
			  System.out.println(q); 
		   } 
		  catch(Exception err)
		  { 
			  err.printStackTrace();
			  System.out.println(err); 
		  } 
		   System.out.println("After division");
		   
		   
	finally block:
	-------------
		- it is used to execute a lock of code regardless of an exception in the try block.
		
		- if you need a block of code to be executed even if there is an exception in the try block, then we keep such code inside the finally block.
		
		- a try block can have a multiple catch blocks
		- when we have multiple catch blocks, the order of the catch block is important 
		- the parent exception must always be at the bottom of the child exception.
		
		
		- a try block can exists without a catch block also, but it must be followed with a finally block when there is no catch block.
		
	throws key word:
	----------------
		- the throws keyword in java is used to declare exceptions that a method might throw during its execution.
		- it informs the caller of the method that it must handle or propagate the exception.
		
		syntax of throws:
		
		return_type methodName() throws Exception_type_1, Exception_type_2{
			//method logic that cause exception
		}
		
		- if a method contains the code that might throw a checked exception, it must either handle it using try-catch or declare it using
			a throws keyword.
			
		- unchecked exception like ArithmeticException or NullPointerException dont require declaration,
			but still the exception is propagated to the caller method.


UNCHECKED EXCEPTION HANDLING:
==========================
package ExceptionHandling;

public class Test {
	public void method1() throws ArithmeticException {
		System.out.println("In method1()");
		int result = 10 / 0;
	}

	public void method2() {
		System.out.println("In method2()");
		try {
			method1();
		}catch(ArithmeticException e){
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {
		System.out.println("prg started..");
		Test t = new Test();
		t.method2();
		System.out.println("prg ended..");
	}
}
CHECKED EXCEPTION HANDLING:
==========================
package ExceptionHandling;

import java.io.FileReader;
import java.io.IOException;

public class Test2 {
	public void method1() throws IOException {
		System.out.println("In method1()");
		FileReader file = new FileReader("abc.txt");
	}

	public void method2() {
		System.out.println("In method2()");
		try {
			method1();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {
		System.out.println("prg started..");
		Test2 t = new Test2();
		t.method2();
		System.out.println("prg ended..");
	}
}

Exception propagation ==> using throws keyword ==> exception thrown to the caller method where we have to handle exception.
=====================

	Exception propagation refers to how exceptions move thorugh the call stack/runtime_stack when they are not handled in the method where they occur
	
	- main thread:
		when a java program starts up, one thread begins running immediately, this is usually called main thread of our program.
			- A thread refers to a sequence of instructions.
			- for every thread, JVM will create a separate stack at the time of thread creation.
			- All method calls performed by that thread will be in that stack.
			- Each entry in the stack is called 'Stack frame' or 'Activation record'.
			- After completing every method call, JVM removes the corresponding entry from the stack.
			- After completing all method calls, JVM destroy the empty stack and terminates the program normally.
	
	Incase of an exception:
		- if an exception is raised inside any method, the JRE will create exception object with following info:
			- Name of the exception, description, location of the exception.
			- location of the exception is also known as stacktrace.
		- JVM checks whether the method contains any exception handling code or not.
		- if the method doesnt have exception handling code, jvm terminate the method abnormally and removes the corresponding
			entry(stackframe) from the stack.
		- jvm will identify the caller method and checks whether there is any exception handling code in the caller method or not.
			if the caller method also doesnt have any exception handling code, JVM terminates caller method, and it checks the caller of this
			method for exception handling code.
		- Finally main method will also be checked , if main() method doesnt have any exception handling code, JVM removes main() also from stack and
			stack is destroyed
	
	- JVM will handover the responsiblity of the exception handling to "default exception handler".
	- Default Exception handler just prints the exception information to the console.
	
package ExceptionHandling;

public class Test3 {
	public void doMoreStuff(){
		System.out.println("Do more Stuff method called..!");
		int result = 10 / 0;
		System.out.println("Do more stuff method completed..!");
	}

	public void doStuff() {
		System.out.println("do Stuff method called..!");

		doMoreStuff();

		System.out.println("Do stuff method completed..!");
	}

	public static void main(String[] args) {
		System.out.println("Main method called..!");
		Test3 t = new Test3();
		t.doStuff();
		System.out.println("Main method completed..!");
	}
}
	
Main method called..!
do Stuff method called..!
Do more Stuff method called..!
Exception in thread "main" java.lang.ArithmeticException: / by zero
	at ExceptionHandling.Test3.doMoreStuff(Test3.java:6)
	at ExceptionHandling.Test3.doStuff(Test3.java:13)
	at ExceptionHandling.Test3.main(Test3.java:21)
	

package ExceptionHandling;

public class Test3 {
	public void doMoreStuff() throws Exception {
		System.out.println("Do more Stuff method called..!");
		int result = 10 / 0;
		System.out.println("Do more stuff method completed..!");
	}

	public void doStuff() throws Exception {
		System.out.println("do Stuff method called..!");

		doMoreStuff();

		System.out.println("Do stuff method completed..!");
	}

	public static void main(String[] args) {
		System.out.println("Main method called..!");
		Test3 t = new Test3();
		try {
			t.doStuff();
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("Main method completed..!");
	}
}

Main method called..!
do Stuff method called..!
Do more Stuff method called..!
java.lang.ArithmeticException: / by zero
	at ExceptionHandling.Test3.doMoreStuff(Test3.java:6)
	at ExceptionHandling.Test3.doStuff(Test3.java:13)
	at ExceptionHandling.Test3.main(Test3.java:22)
Main method completed..!


	Custom Exceptions:
	------------------	A custom exception is a user-defined exception class.
		It extends either:
		- Exception class (or), generally extended to create checked exceptions.
		- RuntimeException - extended to create runtimeexception.
	Custom exceptions are useful when builtin exceptions do not fit.
	for a specific requirement.
	
	Steps to create a custom exception:
	
	- extend Exception or RuntimeException
	- provide a constructor that accepts error messages.
	
	-throw  keyword is used to explicitly throw the exception from  a method or a block of code.
  synatx:
  throw new ExceptionType("Error message");
  -throw is used manually throw'/raise an exception
  -It must be followed by an instance of the class that inherits from the throwable(like Exception or RunTimeException)
  
  Difference between throws and throw :
  ------------------------------------
  1. throws keyword is used in method  declaration to declare that the method throw an exception.
     throw keyword is used throw an exception.
 2.  throws is used in method signature 
     throw  is uded inside a method  or a block 
  3. We can use throws with one or more Exception class names.
     throw is used with single instance of Exception class.
 
Union catch blocks:
-------------------
-To reduce the boiler plate code,java 7 introduced Union catch blocks
-They allow us to treat multiple exceptions in the same manner and handle their exceptions in  a single block.
Syntax:
try{
 //somecode
  }catch(Exception1 | Exception2 ex){
    //handle
    }
 Various methods to print exception information:
1.printstackTrace(): This method prints exception information in the following format
                   Name of the  Exception: description of exception
                   stacktrace(location of the exception)
2.getMessage():  This method returns only the description part of the exception information.

3. tostring(): This method prints exception information in the format:
               Name of the Exception: description of the exception	
 
 --------------------------------------------------------------------------------------------------
 Thread:
 -Thread is an executional path or sequence in a program.
 -a thread is a unit of execution which allows concurrent execution of multiple parts in a program
 -By default every program is run by JVM,
  JVM will create a default thread called 'main' thread.
  main thread is not as same as main method  .
  by default main thread is used by jvm to run the program.
  
  Multitasking means doing multiple things at the same time
  
  Process is an independent program in execution .
  -Each process is managed by Operating system.
  -Each process will have a thread called main thread by default.
  -A thread is a smallest unit of execution with in a process.
  
  steps:
  1.OS will create Process
  2.An instance of JVM will be created by OS
     (Main thread -created by JVM)
  3.Other threads:Created by  our code
  4.Stack:Each thread will have its own stack
  
  Thread.sleep(ms);
  
  - Thread.sleep(long milliseconds);
  - pause the current thread for specified milliseconds of time.
  - it temporarily stops the execution, allowing other threads to run.
  eg: Thread.sleep(1000) -> will pause the thread for 1000ms or 1 second.
  
  InterruptedException:
  - sleep() method throws a checked exception called 'InterruptedException'
  - so it must be handled by try/catch block
  - it may occur due to the following scenarios:
	- when a thread is sleep using Thread.sleep(), another thread interrupts it by calling Thread.interrupt();
  - Thread is in waiting stage.
  - when the thread is blocked in join()
  
  Thread Priorities:
  ------------------
	- Every java thread has a priority assigned btw 1 to 10.
	- if you do not set any priority to a thread, the default priority would be 5.
	
		constant					value			Description
		Thread.MIN_PRIORITY			1				Lowest priority- thread get least CPU Time.
		Thread.NORM_PRIORITY		5				Default priority for all threads.
		Thread.MAX_PRIORITY			10				Highest priority - may get more preference by Thread scheduler
		
	Thread Creation:
	---------------		- A thread can be created by extending thread class
						- A thread can also be created by implementing runnable interface.
						
	Runnable interface: 
		- Runnable interface in java.lang package.
		- Its afunctional interface, meaning, it has a single abstract method.
		- it has a single abstract method called run()
		
		Steps to create a Thread using runnable interface.
		1. create a class that implements Runnable interface.
		2. Override run() method, in the run method provide the functionality of the thread.
		3. TO use the runnable Thread, Create an object of runnable class(A class which implements Runnable)
		4. pass the object reference to a Thread class constructor.
		5. call the start() to start the runnable Thread.
		
	join(): It is used to pause the execution of the current thread.(Main Thread) until the thread on which it is called has finished executing.
		
		Syntax:	public void join() throws InterruptedException
				public void join(long milliseconds) throws InterruptedException
				
	- join() ensures the one threas completed before another thread starts.
	- It is generally used when one thread depends on the other.
	- Helps in sequential execution with in a multithreaded program.
	
	eg: Thread t1 = new Thread(new MyTask());
	
		t1.start();
		try{
			t1.join();
		}catch(InterruptedException e){
			e.printStackTrace();
		}
		
		In the above, the main thread will pause at t1.join()
		main thread will continue only after t1 finishes.
		
Synchronized Keyword:
-------------------
  -sysnchronized can be applied on methods and block
  synchronized{
  
  //code block
  }
  or
  
  public synchronized void methodname(){
  
  }
  
   Purpose of synchronization
   
  -To prevent multiple threads from accessing shared resources at the same time.
  -This is to avoid data inconsistency.
  -when synchronized keyword is applied to a method or block only one thread at a  time can execute 
   a synchronized block/method on the same object.
  -When a thread enters a synchronized block or method,it acquires lock on the object.
   Other threads which try to enter synchronized code on the same object will be blocked until lock is released.
  -Locking mechanism prevents multiple threads from accessing a shared resource at same time.
  -These locks are also called Monitors.
  
  wait(),notify(),notifyAll();
  ----------------------------
  -The above are the methods which belong to Object class.
  -They do not belong to Thread class.
  -These methods are used for inter-thread commmunication
  
  wait():
  -wait() method cause the current thread to wait until another thread calls notify().
  
  notify():
  -notify() method is used for waking up the waiting thread.
  
  notifyAll():Wakes up all waiting threads .
  
  -These methods must be called from synchronized context.
  -Whenever a thread calls a wait(),it releases the lock and goes into a waiting state.
  -when notify() is called,one waiting thread is  awakened.
  -the awakened thread which was earlier in waiting state,it needs to require the lock to continueits execution.
  
  
  example flow of cofeemachine-
  Custom Thread:
  Staff Thread:
  
  1.Customer Thread is used to call makecoffee() method.
    from cofffeeMachine class.
  2.Staff Thread is used for calling fillwater() method of CoffeMachine class.
  3. when the  customer thread calls makeCoffe(),it will check whether water is filled filled or not.
  4.If no water it will just call wait() method,it release  the lock and goes into waiting state.
  5. So until now, the customer thread is holding the lock on coffeeMachine object.
     As soon as it calls wait() method , it release the  lock on coffeeMachine object.
  6. Next staff thread will new acqurie the lock on the object.
	It will call fillwater() method on the object.
    And then it calls notify().
    Staff thread releases the lock on coffeeMachine object.
  7. Customer Thread which is in waiting state, will now awakedned.
    It will re-acqurie the lockandcontinue
	
  Thread states:
  ---------------
  A thread  will eneter into different states during its lifecycle.
  6 stages of Thread:
  
  1.New State or Born State :
   A thread is created,but not start.
   eg: Thread t=newThread();//new state
   
  2.Runnable state:
   -The thread is ready to run,but CPU may not be executing it yet.
   -Thread goes to runnable stae when you call start() method.
   
  3.Blocked State:
    The thread is said to be blocked state ,
    when the thread is waiting to acquire a lock(another thread is hold in the lock)
    -Thread is  generally  in blockstate when two or more threads try to enter a
      synchronized block on the same object
    
  4.Waiting state :
  -Thread is said to be in waiting state when the thread is waiting continously for another 
   thread to perform an action.
   -A thread can eneter to waiting state by calling
     -wait()
     -join()
     
  5.Time waited state:
  -A thread is said to be in timewaited state,the Thread is waiting,but only for a limited time.
  -a thread enters to waiting state by calling
    -sleep(ms)
     -wait(ms)
     -join(ms)
     
  6.Terminated or Dead state:
  -Thread is said to enter a Terminated state or DeadState  when the thread has finished execution or it is 
   abnormally stopped.
  -Generally when run() is completed or an Exception is thrown during its execution the Thread enters into Terminated
    or Dead state.
    \
    NEW->RUNNABLE->BLOCKED/WAIT/TIME-WAITED<--->RUNNABLE->TERMINATED
	
=========================================================================================================================================	
IO STREAMS:
==========
Stream: Sequence of characters or sequence of bytes.
IO Stream: Input/Out stream
					read						     write
		source ===============> java application =============> Destination
				inputStream						  outputStream
		
	- Input Stream: Reads data from the source./ The characters or bytes that a java application READs is called Input stream.
	- Output Stream: Writes data to a destination./The characters or bytes that a java application WRITEs is called Output Stream.
	
	-I/O Streams are used for storing small amount of data like application settings in a file or for storing log information.
	
	- All classes relates to IOStreams for handling filoes are present in package java.io package.
	-so to use these IO stream classes we need to import java.io package.
	
- Streams are characterized into 2 types:
	a. Character streams:Classes related to Character Streams are generally used to read and write character data or text data.
	b. Byte Streams: Byte Stream classes are used to read and write binary data,
						ex: java objects, images, audio and video files etc.
	
	
	java.io.Reader --> it is an abstract class for reading characters.
		
		Child classes
		- FileReader
		- BufferedReader
		
	
	java.io.Writer --> it is an abstract class for writing characters.
	
		Child classes
		- FileWriter
		- BufferedWriter
	
	java.io.File Class:
		- file class is used to create files and directories.
		- we pass the name of file or directory in the file class constructor.
		- createNewFile() method will create a new file. It throws a checked exception - IOException, which must be handled
		- exists() method returns true, if the file exists, if file doesn't exist , it returns false.
		
	File class constructors:
	
		constructor1:
		File fileRef = new File("name of the file");
		
		constructor2:
		File fileRef = new File(File f,String filename);2
		
		constructor3:
		File fileRef = new File(String subdir,String filename);
		
		
		
	Methods of fileclass:
	
	exists(): returns true if file/directory exists else returns false.
	mkDir(): creates a new directory.
	createNewFile(): creates a new file
	isFile(): check whether the resource is a file or not. returns boolean true if it is a file, else false.
	isDirectory(): check whether the resource is a directory or not. returns boolean true if it is a directory, else false.
	list(): returns a String array, this Array will have the names of the files and subdirectories present in the directory.
	
	
FileWriter class: 
-----------------
		- it is present in java.io package
		- it is a concrete class used to write character data to files.
		- it extends OuputStreamWriter class, which in turn extends the abstracr class 'Writer'.
		
	FileWriter Constructor:
	- FileWriter fw = new FileWriter(String filename);
	- Eg: FileWriter fw2 = new FileWriter("myFile.txt")
	
	constructor2:
	File fileObjRef = new File("fileName");
	FileWriter fw = new FileWriter(fileObjRef);
	
Method of a FileWriter class:
	- write(int char) - writes a single character.
	- write(char[] ch) - writes a character array
	- write(String str) - writes a string
	- flush() - ensures all data is pushed from buffer to file.
	- close() - closes the stream.
	
FileReader:
----------
	- it is a concrete class used to read character data to files.
	read()==> method is used to read, it returns only ascii values in numbers
	
BufferedReader and BufferedWriter:
---------------------------------
	- BufferedWriter and BufferedReader classes internally uses a concept called buffering.
	- buffering is the process of temporarily storing data in memory (RAM), 
		before it is actually read or written to a file or Stream.
	
	- BufferedReader
		- used to read text from a file efficiently.
		- reads the data in chunks into a memory buffer.
		- supports line-by-line reading using readLine() method.
		- since it is not directly reading from the disk, it is much faster.
		- improves the performance when working with large files.
		
	- BufferedWriter:
		- used to write character data to a file.
		- Buffers the data in java memory before writing to a file.
		- Reduces writing to a disk frequently as it uses a buffer.
		- it provides a newLine() method for seperating() a line.
		
	BufferedReader and BufferedWriter are faster than FileReader and FileWriter.
	
	PrintWriter class:
	------------------
		- Most efficient class in java for writing the text data to a file.
		- unlike FileWriter or BufferedWriter, PrintWriter directly writes any data type, int,boolean etc.,
		- we can write data directly ino a file or  through another writer like FileWriter or BufferedWriter.
		
	constructors:
		- PrintWriter pw = new PrintWriter(String Filename);
		eg: PrintWriter pw = new PrintWriter("output.txt");
		
		- PrintWriter pw = new PrintWriter(File file);
		eg: PrintWriter pw = new PrintWriter(new File("ouput.txt"));
		
		- PrintWriter pw = new PrintWriter(Writer writer);
		eg: PrintWriter pw = new PrintWriter(new FileWriter("ouput.txt"));
		
Serialization and Deserialization:
---------------------------------
	- this is also called importing and exporting an object.
	- the state of a java object can be exported to a file, memory or database.
	for eg: when you create a student object, this object remains in the memory as long as you are using in program.
	- once you exit the program, the object is cleanedup in the memory.
	- to save the object in a file system or a database or a memory even when you exit the program, we can use bytestream classes.
	- to save the state of the object, first the object must be converted into a bytestream.
	- the process of converting a object to a bytestream is called serialization.
	- the converted bytestream can be saved as a file, or sent over a network.
	- the bytestream can be saved as a file with .ser extension
	- this file is platform independent
	
Try with resources:
	1. try with resources is another form of try/catch block
		Syntax:
		
			try(Resources which implements AutoCloseable){
				
			}catch(){
				
			}
	2. try with resources, will automatically close the resource without calling the close() method.
	3. Only the classes which implements AutoCloseable interface are used in try with resources block.
	4. It is used with files, sockets and database connections. After their use, they are automatically
		closed to avoid resource leakages.(wasteage of memory)
	5. it is introduced in JAVA 7, as a part of automatic resource management or ARM.
	
Serialization can be performed only for serializable objects.
- An Object is said to be serializable if and only if the class implements serializable interface
- Serializable interface is present in java.io package
- It doesnot contain any methods.

An interface which doesnot have any methods is called marker interface.
- Serializable interface is a marker interface.
- When a class implements serializable interface, it is eligible for Serialization process,
	(JVM will mark that class as the class eligible for serialization)
- if we try to serialize a non-serializable object, i.e., a class which doesnot implement serializable interface,
	then we get a RunTimeException: "NotSerializableException".
	
transient modifier: When a field is declared with transient modifier, the field will not take part in serialization
------------------
process.
EG: private transient String password;
	Here, password will not be saved during serialization
	After deserialization, its value is null.
	
Object Casting:
--------------
	- Object casting is the process of converting one type of object reference to another type.
	- Object casting happens btw parent nad child classes.

	There are 2 types of casting:
	1. Upcasting:
		- Also known as widening casting
		- when a child class object is assigned to a parent class reference.
		
		Syntax:
			Parent p = new Child();
		- it is done automatically, so it is also called as implicit casting.
		- upcasting can access only the parent class methods or variables
		- overridden methods in the child class will be called due to runtime polymorphism.
	2. Down Casting:
		- Also known as Narrowing or Explicit object casting.
		- Downcasting happens when a parent class reference is converted back to child class refernce.
		
		Syntax:	Parent pRef = new Child();
				Child cRef = (Child) pRef;//down casting
		- it must be done explicitly.
		- Down casting must be done only if the object is actually an instance of child class.
		- it is dangerous if bot used carefully, it can cause ClassCastException at runTime.
		
		- it is always a best practice to use the keyword 'instanceof' before downcasting.
		
		syntax of instanceof:
			if(object instanceof ClassName){
				//stats.
			}
			- instanceof is used to check the actual type of an object at runtime.
			- prevents ClassCastException.
			- it returns true if the object is instance of class.
			- it is commonly used before downcasting to avoid errors.
			
	Wrapper class:
	In java primitive data types like int,char,double, etc are not objects, they are primitive types.
	
	- but java is object oriented language and many features like collections work only with objects.
	- so we need  wrapper classes to wrap primitive types to objects.
	
	Different Wrapper classed:
		Primitive Type 							Wrapper Class
		
			byte									Byte
			short									Short
			int										Integer
			long									Long
			float									Float
			double									Double
			char									Character
			boolean									Boolean
			
	Autoboxing: 
	- the automatic conversion of a primitive type to an object type.
	- It is introduced in JAVA 5.
	- Autoboxing happens when:
		- we assign a primitive type to a wrapper object.
		- when we pass a primitive type to a method excepting a wrapper object.
		- when we add a primitive to a collection (eg. ArrayList)
		eg: int i = 10;
		Integer x = i;
		
	Unboxing:
	- Automatic converison of wrapper class object to primitive type.
	- also introduced in JAVA 5.
	- unboxing happens when:
		- you assign a wrapper object to a primitive.
		eg: Integer x = 50;
		int y = x;
	
	
Generics:
	- Generics allows us to write resusable code by parameterizing types.
	- We use a place holder instead of specifying a type.
	syntax:
		class ClassName <T>{
			//code
		}
	In the above syntax we use angle brackets <> to define generic type.
	- Generics will help us to achieve type safety by making sure that only the expected type of objects are added.
	- Type safety will make sure that variables are only assigned values of the expected data type.
	- It prevents type mismatch errors at compile time itself rather than at runtime.
	- without type safety, assigning an incorrect data type to a variable can cause RunTimeException called 'ClassCastException'.
	

Package in java - java.util

Collections Framework:

  - It is architecture for representing and manipulating collection of object.
  - Collections Framework will have the following:
        - Interface
		- implementations
		- Algorithms (Methods)
  - These classes , interfaces and abstract classes are present in java.util package.
  
Collections Framework:
   - privdes predefined classes and interfaces for common data structures.
   - It makes code reusable and efficient.


java.util.Collection Interface:
------------------------------
  - Base interface for many classes in collections framework
  - It is present in java.util package.
     add()
	 addAll()
	 contains()
	 remove()
	 removeAll()

- Names of countries:

List - Allows duplicates
  India
  Japan
  singapore
  Malaysia
  India
  
 java.util.List interface:
 ------------------------
 - extends Collection interface
 - Allows duplicates
 - allows ordered elements
 - Elements are index based
 - common classes - ArrayList, LinkedList, Vector, Stack
 
 
 ArrayList:
 ==========
 - It is an implementation class of list interface.
 - elements are stored in contigious memory location.
 - It is based on resizable or growable array.
 - Heterogeneous object can be stored in a ArrayList
 - Duplicates are allowed
 - Insertion order is preserved.
 - default capacity of ArrayList is 10.
 - if we have frequent insertions and deletion operations in the collection, then ArrayList is not agood option.
 - During insertions or deletions, arrayList has to shift the elements for inserting a new object or to delete an object from ArrayList.
 - Due to this there may be an overhead for the application performance when there are huge number of objects in an arrayList.
 - But arrayList is best option for search operations as it internally implements an interface called 'RandomAccess' Interface.
 - less memory overhead.
 - it internally coverss the object into a String representation as it overrides toString() method.
 LinkedList:
 ==========
  - LinkedList implements List interface.
  - elements are stored in contigious memory location.
  - It is based on doubly linked List.
  - Duplicates are  allowed
  - Nulls are allowed.
  - Heterogeneous objects are allowed.
  - Insertion order is preserved.
  - when ever insertion and deletion occur, only the links will be changed internally. No shifting of the elements.
  - Due to this, it is better choice to use linked list when you have frequent insertions and deletions.
  - LinkedList occupies more memory as it internally maintains extra pointers in node.
  - it internally coverss the object into a String representation as it overrides toString() method.
  
 Vector:
 ======
 - Similar to ArrayList, it is growable array.
 - duplicates are allowed.
 - insertion order is preserved
 - heterogenous objects are allowed.
 - Nulls are allowed.
 - Vectors are thread safe because all these methods are synchronized.
 - it is slower than ArrayList, as it has synchronization overhead.
 
 Stack:
 ======
 - extends vector class
 - it inherits the synchronization properties of vector.
 - stack is based on last in fast out principle.
 - the element added at the end of the list will be removed first.
 - Stack is an implementation of List interface.
 - it extends vector class.
 - Stack is synchronized by default (thread-safe).
 - It is also a legacy class, but also used for stack operations.
 
 Methods of Stack:
 - push(Object o) -> add elements to stack
 - pop() -> remove elements from the top of stack, returns the element at the top of the stack.
 - peek() -> it is used to lookup the element at the top of the stack.
 
 

---------------------------------------------
Cursors: It is a pointer or interface it allows us to traverse/navigate through
elements of a collection one by one.
- Java provides 3 types of cursors:
	1. Enumeration
	2. Iterator
	3. ListIterator
 - Enumeration: 
	- it is used only with legacy classes like vector, stack, hashtable.
	- It can only read the elements. it cannot remove the elements.
	- It is not universal cursor as it only works with legacy classes.
	
	- To get an Enumeration object we use elements() method of vector class.
	eg: Enumeration enumeration = Vector.elements();
	- hasMoreElements() -> true if elements are present.
	- nextElement() -> will retrieve the next element from collection.
	
	












Set - Which does not allows duplicates
  2000
  100
  22
  500  
 java.util.Set interface:
 -----------------------
 - extends Collection interface
 - Does not allow duplicates
 - Unordered collection
 - common classes - HashSet, LinkedHashSet, TreeSet
Set Interface:
=============	Set interface extends collection interface.
Set will not allow duplicate.
Some implementations of Set interface are:
	1. HashSet
	-----------
	- HashSet is an implementation class of Set interface.
	- No Duplicates are allowed.
	- Insertion order is not guaranteed.
	- It allows null value.
	
	- Hashing is the process of mapping data to fixed size integer called hashcode.
	- Internally hash() function is used to generate hashcode.
	- The hash() function takes an input like a String or Number and returns a unique code for that input.
	
Advantages of hashing:
	- Fast data retrieval using hashcode.
	- Efficient for insertion and deletion operations.
	
HashSet internally uses HashMap:
Eg:   Key		 value		(HashMap)
	1234567		Hyderabad	
	2345678		Chennai		

Reason for not maintaining the insertion order in hashset:
a. the position of elements in hashset is not consecutive memory location.
b. Elements position in the memory is determined by using hashvalue. It is not by order of insertion.

	2. LinkedHashSet:
	-----------------
	- It is an implementation of Set interface.
	- It internally uses LinkedHashMap.
	- LinkedHashMap internally uses hashing + LinkedList.
	- It is slightly slower than HashSet because, it maintains a Linkedlist to preserve the order of elements.
	- It consumes more memory as it uses linkedlist to maintain insertion order.
	- Use LinkedHashSet when you need the insertion of the elements. 
		If insertion order is not required, then use HashSet is much faster.
		
	
	
	
	
	
	

	3. TreeSet
 

Map - Which does not allows duplicates
  Key       Value
  India     New Delhi
  US        WashingtonDC
  Japan     Tokyo
  
 java.util.Map interface:
 ------------------------
 - does not extends Collection interface
 - Stores Objects in Key-Values pairs
 - No duplicate Keys, but values can repeat
 - It does not extend Collection
 - Common classes which implement Map interface:
      - HashMap, LinkedHashMap, TreeMap etc...
	  
	  
 java.util.Queue:
 ----------------
 - Based on First In First Out - FIFO
	
		
	
	